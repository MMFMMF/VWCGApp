---
wave: 1
depends_on: []
files_modified:
  - src/components/tools/ReportCenterTool.tsx
  - src/lib/pdf/generator.ts
  - src/lib/tools/index.ts
autonomous: true
---

# Plan: PDF Report Generation

## Objective

Implement the Report Center tool (RPT-01 to RPT-04) - PDF generation with section selection, assessment scores, charts, synthesis insights, and downloadable reports.

## Tasks

### Task 1: Create PDF Generator Library

**Action:** Create PDF generation utility using jsPDF
**Files:** src/lib/pdf/generator.ts
**Details:**

```typescript
import jsPDF from 'jspdf';
import type { SynthesisResult, Insight } from '@lib/synthesis/types';

interface ReportSection {
  toolId: string;
  toolName: string;
  enabled: boolean;
  data: unknown;
  pdfExport?: {
    title: string;
    summary: string;
    tables?: { headers: string[]; rows: string[][] }[];
    insights?: string[];
  };
}

interface ReportConfig {
  workspaceName: string;
  companyName: string;
  generatedAt: Date;
  sections: ReportSection[];
  synthesisResult?: SynthesisResult;
  includeInsights: boolean;
}

const COLORS = {
  primary: '#4F46E5',
  secondary: '#6B7280',
  success: '#10B981',
  warning: '#F59E0B',
  danger: '#EF4444',
  text: '#1F2937',
  lightGray: '#F3F4F6'
};

export async function generatePDFReport(config: ReportConfig): Promise<Blob> {
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4'
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 20;
  const contentWidth = pageWidth - 2 * margin;
  let yPos = margin;

  // Helper functions
  const addPage = () => {
    doc.addPage();
    yPos = margin;
  };

  const checkPageBreak = (neededHeight: number) => {
    if (yPos + neededHeight > pageHeight - margin) {
      addPage();
      return true;
    }
    return false;
  };

  const drawLine = (y: number, color = COLORS.lightGray) => {
    doc.setDrawColor(color);
    doc.setLineWidth(0.5);
    doc.line(margin, y, pageWidth - margin, y);
  };

  // === COVER PAGE ===
  // Title
  doc.setFontSize(28);
  doc.setTextColor(COLORS.primary);
  doc.text('Business Assessment Report', pageWidth / 2, 60, { align: 'center' });

  // Company name
  doc.setFontSize(18);
  doc.setTextColor(COLORS.text);
  doc.text(config.companyName || 'Your Business', pageWidth / 2, 80, { align: 'center' });

  // Workspace name
  doc.setFontSize(12);
  doc.setTextColor(COLORS.secondary);
  doc.text(`Workspace: ${config.workspaceName}`, pageWidth / 2, 95, { align: 'center' });

  // Generated date
  doc.setFontSize(10);
  doc.text(
    `Generated: ${config.generatedAt.toLocaleDateString()} at ${config.generatedAt.toLocaleTimeString()}`,
    pageWidth / 2,
    105,
    { align: 'center' }
  );

  // Section count
  const enabledSections = config.sections.filter(s => s.enabled);
  doc.setFontSize(11);
  doc.setTextColor(COLORS.text);
  doc.text(`${enabledSections.length} assessment sections included`, pageWidth / 2, 120, { align: 'center' });

  // Insights count
  if (config.includeInsights && config.synthesisResult) {
    const insightCount = config.synthesisResult.insights.length;
    doc.text(`${insightCount} synthesis insights generated`, pageWidth / 2, 130, { align: 'center' });
  }

  // Footer on cover
  doc.setFontSize(8);
  doc.setTextColor(COLORS.secondary);
  doc.text('Generated by VWCGApp - Value-Weighted Capability Gap Assessment', pageWidth / 2, pageHeight - 20, { align: 'center' });

  // === TABLE OF CONTENTS ===
  addPage();
  doc.setFontSize(18);
  doc.setTextColor(COLORS.primary);
  doc.text('Table of Contents', margin, yPos);
  yPos += 15;

  doc.setFontSize(11);
  doc.setTextColor(COLORS.text);
  let tocPage = 3; // Start after cover and TOC

  enabledSections.forEach((section, idx) => {
    doc.text(`${idx + 1}. ${section.toolName}`, margin, yPos);
    doc.text(`Page ${tocPage}`, pageWidth - margin - 20, yPos);
    yPos += 8;
    tocPage++; // Approximate - each section ~1 page
  });

  if (config.includeInsights && config.synthesisResult?.insights.length) {
    yPos += 5;
    doc.text('Synthesis Insights', margin, yPos);
    doc.text(`Page ${tocPage}`, pageWidth - margin - 20, yPos);
  }

  // === ASSESSMENT SECTIONS ===
  for (const section of enabledSections) {
    addPage();

    // Section header
    doc.setFontSize(16);
    doc.setTextColor(COLORS.primary);
    doc.text(section.pdfExport?.title || section.toolName, margin, yPos);
    yPos += 10;

    // Summary
    if (section.pdfExport?.summary) {
      doc.setFontSize(11);
      doc.setTextColor(COLORS.secondary);
      const summaryLines = doc.splitTextToSize(section.pdfExport.summary, contentWidth);
      doc.text(summaryLines, margin, yPos);
      yPos += summaryLines.length * 5 + 5;
    }

    drawLine(yPos);
    yPos += 8;

    // Tables
    if (section.pdfExport?.tables) {
      for (const table of section.pdfExport.tables) {
        checkPageBreak(50);

        // Table header
        doc.setFillColor(COLORS.lightGray);
        doc.rect(margin, yPos - 2, contentWidth, 8, 'F');

        doc.setFontSize(9);
        doc.setTextColor(COLORS.text);
        const colWidth = contentWidth / table.headers.length;

        table.headers.forEach((header, idx) => {
          doc.setFont('helvetica', 'bold');
          doc.text(header, margin + idx * colWidth + 2, yPos + 3);
        });
        yPos += 10;

        // Table rows
        doc.setFont('helvetica', 'normal');
        for (const row of table.rows) {
          checkPageBreak(8);
          row.forEach((cell, idx) => {
            const cellText = doc.splitTextToSize(cell, colWidth - 4);
            doc.text(cellText[0] || '', margin + idx * colWidth + 2, yPos);
          });
          yPos += 6;
        }
        yPos += 5;
      }
    }

    // Insights from this section
    if (section.pdfExport?.insights && section.pdfExport.insights.length > 0) {
      checkPageBreak(30);
      doc.setFontSize(11);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(COLORS.text);
      doc.text('Key Findings:', margin, yPos);
      yPos += 7;

      doc.setFont('helvetica', 'normal');
      doc.setFontSize(10);
      for (const insight of section.pdfExport.insights) {
        checkPageBreak(10);
        const bulletText = `â€¢ ${insight}`;
        const lines = doc.splitTextToSize(bulletText, contentWidth - 5);
        doc.text(lines, margin + 3, yPos);
        yPos += lines.length * 5 + 2;
      }
    }
  }

  // === SYNTHESIS INSIGHTS SECTION ===
  if (config.includeInsights && config.synthesisResult?.insights.length) {
    addPage();

    doc.setFontSize(18);
    doc.setTextColor(COLORS.primary);
    doc.text('Synthesis Insights', margin, yPos);
    yPos += 12;

    doc.setFontSize(10);
    doc.setTextColor(COLORS.secondary);
    doc.text(
      `${config.synthesisResult.insights.length} insights from ${config.synthesisResult.rulesEvaluated} analysis rules`,
      margin,
      yPos
    );
    yPos += 10;

    drawLine(yPos);
    yPos += 8;

    // Group insights by type
    const insightsByType: Record<string, Insight[]> = {
      gap: [],
      warning: [],
      opportunity: [],
      strength: []
    };

    config.synthesisResult.insights.forEach(insight => {
      insightsByType[insight.type].push(insight);
    });

    const typeLabels = {
      gap: { label: 'Gaps & Risks', color: COLORS.danger },
      warning: { label: 'Warnings', color: COLORS.warning },
      opportunity: { label: 'Opportunities', color: COLORS.primary },
      strength: { label: 'Strengths', color: COLORS.success }
    };

    for (const [type, insights] of Object.entries(insightsByType)) {
      if (insights.length === 0) continue;

      checkPageBreak(25);

      const typeConfig = typeLabels[type as keyof typeof typeLabels];
      doc.setFontSize(12);
      doc.setTextColor(typeConfig.color);
      doc.setFont('helvetica', 'bold');
      doc.text(`${typeConfig.label} (${insights.length})`, margin, yPos);
      yPos += 8;

      doc.setFont('helvetica', 'normal');
      doc.setFontSize(10);
      doc.setTextColor(COLORS.text);

      for (const insight of insights) {
        checkPageBreak(25);

        // Severity badge
        const severityLabel = insight.severity >= 4 ? 'HIGH' : insight.severity >= 3 ? 'MED' : 'LOW';
        doc.setFillColor(insight.severity >= 4 ? COLORS.danger : insight.severity >= 3 ? COLORS.warning : COLORS.success);
        doc.roundedRect(margin, yPos - 3, 12, 5, 1, 1, 'F');
        doc.setTextColor('#FFFFFF');
        doc.setFontSize(7);
        doc.text(severityLabel, margin + 2, yPos);

        // Title
        doc.setFontSize(10);
        doc.setTextColor(COLORS.text);
        doc.setFont('helvetica', 'bold');
        doc.text(insight.title, margin + 15, yPos);
        yPos += 6;

        // Description
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(9);
        const descLines = doc.splitTextToSize(insight.description, contentWidth - 15);
        doc.text(descLines, margin + 15, yPos);
        yPos += descLines.length * 4 + 3;

        // Recommendation
        doc.setFontSize(8);
        doc.setTextColor(COLORS.secondary);
        const recLines = doc.splitTextToSize(`Recommendation: ${insight.recommendation}`, contentWidth - 15);
        doc.text(recLines, margin + 15, yPos);
        yPos += recLines.length * 4 + 6;
      }
    }
  }

  // === FOOTER ON ALL PAGES ===
  const totalPages = doc.getNumberOfPages();
  for (let i = 1; i <= totalPages; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setTextColor(COLORS.secondary);
    doc.text(`Page ${i} of ${totalPages}`, pageWidth / 2, pageHeight - 10, { align: 'center' });
  }

  return doc.output('blob');
}

export function getReportFilename(workspaceName: string): string {
  const safeName = workspaceName.replace(/[^a-zA-Z0-9]/g, '_');
  return `VWCGReport_${safeName}.pdf`;
}
```

### Task 2: Create Report Center Tool Component

**Action:** Create the Report Center with section selection and PDF download
**Files:** src/components/tools/ReportCenterTool.tsx
**Details:**

```typescript
import { useState, useEffect, useMemo } from 'react';
import type { ToolProps, ValidationResult, PDFSection } from '@types/tool';
import { toolRegistry } from '@lib/tools';
import { useWorkspaceStore } from '@stores/workspaceStore';
import { generatePDFReport, getReportFilename } from '@lib/pdf/generator';
import {
  Card,
  CardHeader,
  CardTitle,
  Button,
  Badge
} from '@components/shared';

interface ReportCenterData {
  selectedSections: string[];
  includeInsights: boolean;
  lastGenerated: number | null;
}

const defaultData: ReportCenterData = {
  selectedSections: [],
  includeInsights: true,
  lastGenerated: null
};

export default function ReportCenterTool({ data, onUpdate, readonly = false }: ToolProps) {
  const [formData, setFormData] = useState<ReportCenterData>(
    (data as ReportCenterData) || defaultData
  );
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const currentWorkspace = useWorkspaceStore(state => state.currentWorkspace);
  const synthesisResult = useWorkspaceStore(state => state.synthesisResult);
  const allTools = toolRegistry.getAll();

  useEffect(() => {
    if (data) setFormData(data as ReportCenterData);
  }, [data]);

  // Get exportable tools (exclude report center itself and insights dashboard)
  const exportableTools = useMemo(() => {
    return allTools
      .filter(t => t.metadata.id !== 'report-center' && t.metadata.id !== 'insights-dashboard')
      .map(tool => {
        const toolData = currentWorkspace?.toolData?.[tool.metadata.id];
        const hasData = toolData && Object.keys(toolData).length > 0;
        let pdfExport = null;

        if (hasData && tool.exportToPDF) {
          try {
            pdfExport = tool.exportToPDF(toolData);
          } catch (e) {
            console.error(`Failed to get PDF export for ${tool.metadata.id}:`, e);
          }
        }

        return {
          id: tool.metadata.id,
          name: tool.metadata.name,
          category: tool.metadata.category,
          hasData,
          pdfExport
        };
      })
      .sort((a, b) => {
        // Sort by category then by name
        if (a.category !== b.category) return a.category.localeCompare(b.category);
        return a.name.localeCompare(b.name);
      });
  }, [allTools, currentWorkspace]);

  // Auto-select all tools with data on first load
  useEffect(() => {
    if (formData.selectedSections.length === 0) {
      const withData = exportableTools.filter(t => t.hasData).map(t => t.id);
      if (withData.length > 0) {
        const updated = { ...formData, selectedSections: withData };
        setFormData(updated);
        onUpdate?.(updated);
      }
    }
  }, [exportableTools]);

  const toggleSection = (toolId: string) => {
    const updated = {
      ...formData,
      selectedSections: formData.selectedSections.includes(toolId)
        ? formData.selectedSections.filter(id => id !== toolId)
        : [...formData.selectedSections, toolId]
    };
    setFormData(updated);
    onUpdate?.(updated);
  };

  const selectAll = () => {
    const allWithData = exportableTools.filter(t => t.hasData).map(t => t.id);
    const updated = { ...formData, selectedSections: allWithData };
    setFormData(updated);
    onUpdate?.(updated);
  };

  const selectNone = () => {
    const updated = { ...formData, selectedSections: [] };
    setFormData(updated);
    onUpdate?.(updated);
  };

  const toggleInsights = () => {
    const updated = { ...formData, includeInsights: !formData.includeInsights };
    setFormData(updated);
    onUpdate?.(updated);
  };

  const generateReport = async () => {
    setIsGenerating(true);
    setError(null);

    try {
      const sections = exportableTools
        .filter(t => formData.selectedSections.includes(t.id))
        .map(t => ({
          toolId: t.id,
          toolName: t.name,
          enabled: true,
          data: currentWorkspace?.toolData?.[t.id],
          pdfExport: t.pdfExport
        }));

      const blob = await generatePDFReport({
        workspaceName: currentWorkspace?.name || 'Workspace',
        companyName: currentWorkspace?.meta?.companyName || '',
        generatedAt: new Date(),
        sections,
        synthesisResult: formData.includeInsights ? synthesisResult : undefined,
        includeInsights: formData.includeInsights
      });

      // Download the PDF (RPT-04)
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = getReportFilename(currentWorkspace?.name || 'Workspace');
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      // Update last generated
      const updated = { ...formData, lastGenerated: Date.now() };
      setFormData(updated);
      onUpdate?.(updated);
    } catch (e) {
      console.error('PDF generation failed:', e);
      setError('Failed to generate PDF. Please try again.');
    } finally {
      setIsGenerating(false);
    }
  };

  // Statistics
  const stats = {
    totalTools: exportableTools.length,
    withData: exportableTools.filter(t => t.hasData).length,
    selected: formData.selectedSections.length,
    insightCount: synthesisResult?.insights.length || 0
  };

  // Group tools by category
  const toolsByCategory = useMemo(() => {
    const grouped: Record<string, typeof exportableTools> = {};
    exportableTools.forEach(tool => {
      if (!grouped[tool.category]) grouped[tool.category] = [];
      grouped[tool.category].push(tool);
    });
    return grouped;
  }, [exportableTools]);

  const categoryLabels: Record<string, string> = {
    assessment: 'Assessment Tools',
    planning: 'Planning Tools',
    synthesis: 'Analysis Tools'
  };

  return (
    <div className="space-y-6">
      {/* Summary */}
      <Card>
        <div className="flex items-center justify-between">
          <div>
            <h3 className="text-lg font-semibold">Report Center</h3>
            <p className="text-sm text-gray-500">
              Generate a comprehensive PDF report of your assessments
            </p>
          </div>
          <div className="text-right">
            <div className="text-2xl font-bold text-indigo-600">{stats.selected}</div>
            <div className="text-xs text-gray-500">sections selected</div>
          </div>
        </div>

        {formData.lastGenerated && (
          <div className="mt-4 text-sm text-gray-500">
            Last report generated: {new Date(formData.lastGenerated).toLocaleString()}
          </div>
        )}
      </Card>

      {/* Section Selection (RPT-01) */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle>Select Report Sections</CardTitle>
            <div className="flex gap-2">
              <Button size="sm" variant="secondary" onClick={selectAll}>
                Select All
              </Button>
              <Button size="sm" variant="secondary" onClick={selectNone}>
                Clear
              </Button>
            </div>
          </div>
        </CardHeader>

        <div className="space-y-6">
          {Object.entries(toolsByCategory).map(([category, tools]) => (
            <div key={category}>
              <h4 className="text-sm font-medium text-gray-700 mb-2">
                {categoryLabels[category] || category}
              </h4>
              <div className="grid md:grid-cols-2 gap-2">
                {tools.map(tool => (
                  <label
                    key={tool.id}
                    className={`flex items-center gap-3 p-3 rounded-lg border cursor-pointer transition-colors ${
                      formData.selectedSections.includes(tool.id)
                        ? 'border-indigo-500 bg-indigo-50'
                        : 'border-gray-200 hover:bg-gray-50'
                    } ${!tool.hasData ? 'opacity-50' : ''}`}
                  >
                    <input
                      type="checkbox"
                      checked={formData.selectedSections.includes(tool.id)}
                      onChange={() => toggleSection(tool.id)}
                      disabled={!tool.hasData || readonly}
                      className="rounded text-indigo-600"
                    />
                    <div className="flex-1">
                      <div className="font-medium text-sm">{tool.name}</div>
                      {!tool.hasData && (
                        <div className="text-xs text-gray-400">No data yet</div>
                      )}
                    </div>
                    {tool.hasData && (
                      <Badge variant="success" size="sm">Ready</Badge>
                    )}
                  </label>
                ))}
              </div>
            </div>
          ))}
        </div>
      </Card>

      {/* Synthesis Insights Option */}
      <Card>
        <label className="flex items-center gap-3 cursor-pointer">
          <input
            type="checkbox"
            checked={formData.includeInsights}
            onChange={toggleInsights}
            disabled={readonly}
            className="rounded text-indigo-600"
          />
          <div className="flex-1">
            <div className="font-medium">Include Synthesis Insights</div>
            <div className="text-sm text-gray-500">
              Add cross-tool analysis findings to the report
            </div>
          </div>
          {stats.insightCount > 0 && (
            <Badge variant="warning">{stats.insightCount} insights</Badge>
          )}
        </label>
      </Card>

      {/* Preview & Generate */}
      <Card>
        <CardHeader>
          <CardTitle>Report Preview</CardTitle>
        </CardHeader>

        <div className="bg-gray-50 rounded-lg p-4 mb-4">
          <div className="text-sm space-y-1">
            <div><strong>Workspace:</strong> {currentWorkspace?.name || 'Unnamed'}</div>
            <div><strong>Sections:</strong> {stats.selected} of {stats.withData} available</div>
            {formData.includeInsights && (
              <div><strong>Insights:</strong> {stats.insightCount} synthesis findings</div>
            )}
            <div><strong>Format:</strong> PDF (A4 Portrait)</div>
          </div>
        </div>

        {error && (
          <div className="bg-red-50 text-red-700 p-3 rounded-lg mb-4 text-sm">
            {error}
          </div>
        )}

        {/* Generate Button (RPT-02, RPT-03, RPT-04) */}
        <Button
          variant="primary"
          onClick={generateReport}
          disabled={isGenerating || stats.selected === 0 || readonly}
          className="w-full"
        >
          {isGenerating ? (
            <>Generating PDF...</>
          ) : (
            <>Download Report ({stats.selected} sections)</>
          )}
        </Button>

        {stats.selected === 0 && (
          <p className="text-sm text-gray-500 text-center mt-2">
            Select at least one section to generate a report
          </p>
        )}
      </Card>
    </div>
  );
}

// Validation
export function validateReportCenter(data: unknown): ValidationResult {
  return { valid: true, errors: [], warnings: [] };
}

// PDF Export (meta - this tool doesn't export itself)
export function exportReportCenterToPDF(): PDFSection {
  return {
    title: 'Report Center',
    summary: 'Report generation tool',
    tables: [],
    insights: [],
    rawData: {}
  };
}

// Register
toolRegistry.register({
  metadata: {
    id: 'report-center',
    name: 'Report Center',
    description: 'Generate and download comprehensive PDF reports',
    category: 'synthesis',
    order: 11,
    estimatedTime: 2
  },
  component: ReportCenterTool,
  validate: validateReportCenter,
  exportToPDF: exportReportCenterToPDF,
  getDefaultData: () => defaultData
});
```

### Task 3: Install jsPDF Dependency

**Action:** Install jsPDF library
**Files:** package.json
**Details:**

```bash
npm install jspdf
```

### Task 4: Update Tool Registry Index

**Action:** Import the Report Center tool
**Files:** src/lib/tools/index.ts
**Details:**

```typescript
import '../../components/tools/ReportCenterTool';
```

### Task 5: Verify Build

**Action:** Run build to verify no errors
**Files:** N/A

## Verification

- [ ] jsPDF library installed successfully
- [ ] Report Center tool renders with section checkboxes
- [ ] Tools grouped by category (assessment, planning, synthesis)
- [ ] Select All / Clear buttons work
- [ ] Include Insights toggle works
- [ ] PDF generates with selected sections
- [ ] PDF includes cover page with workspace info
- [ ] PDF includes table of contents
- [ ] PDF includes assessment data tables
- [ ] PDF includes synthesis insights section (if enabled)
- [ ] Download triggers with correct filename (VWCGReport_[name].pdf)
- [ ] Build completes successfully

## Must-Haves

- RPT-01: Section selection for PDF generation (checkboxes per tool)
- RPT-02: PDF generation with selected sections (jsPDF)
- RPT-03: Report includes assessment scores, charts, and synthesis insights
- RPT-04: Download as VWCGReport_[workspace-name].pdf
- Self-registering tool pattern
