---
wave: 2
depends_on:
  - 02-PLAN-zustand-store
files_modified:
  - src/lib/synthesis/types.ts
  - src/lib/synthesis/ruleRegistry.ts
  - src/lib/synthesis/index.ts
  - src/hooks/useSynthesis.ts
autonomous: true
---

# Plan: Synthesis Rule Registry

## Objective

Implement the synthesis rule registry pattern that allows adding new business logic rules without modifying the core engine. This fulfills requirement ARC-05 (synthesis rule registry for adding new rules without modifying engine core).

## Tasks

### Task 1: Define Synthesis Types

**Action:** Create TypeScript interfaces for synthesis rules, insights, and context
**Files:** src/lib/synthesis/types.ts
**Details:**

```typescript
/**
 * Context passed to every synthesis rule for evaluation
 */
export interface SynthesisContext {
  /** All tool data from workspace keyed by tool ID */
  tools: Record<string, unknown>;

  /** Workspace metadata */
  meta: {
    companyName: string;
    assessmentDate: string;
  };
}

/**
 * Insight generated by a synthesis rule
 */
export interface Insight {
  /** Unique identifier for this insight instance */
  id: string;

  /** ID of the rule that generated this insight */
  ruleId: string;

  /** Type of insight */
  type: 'gap' | 'strength' | 'warning' | 'opportunity';

  /** Severity level (1=low, 5=critical) */
  severity: 1 | 2 | 3 | 4 | 5;

  /** Short, descriptive title */
  title: string;

  /** Detailed description of the finding */
  description: string;

  /** Actionable recommendation */
  recommendation: string;

  /** IDs of tools that contributed to this insight */
  affectedTools: string[];

  /** Optional additional data for rendering/export */
  data?: Record<string, unknown>;
}

/**
 * Definition of a synthesis rule
 */
export interface SynthesisRule {
  /** Unique rule identifier (e.g., 'E1-execution-capability-gap') */
  id: string;

  /** Human-readable name */
  name: string;

  /** Rule description */
  description: string;

  /** List of tool IDs this rule requires to run */
  requiredTools: string[];

  /** Execute the rule and return any generated insights */
  evaluate: (context: SynthesisContext) => Insight[];

  /** Optional: Calculate dimension scores for synthesis dashboard */
  calculateScores?: (context: SynthesisContext) => Record<string, number>;
}

/**
 * Result of running all synthesis rules
 */
export interface SynthesisResult {
  /** All generated insights, prioritized by severity */
  insights: Insight[];

  /** Calculated scores from rules that provide them */
  scores: Record<string, number>;

  /** Timestamp when synthesis was run */
  timestamp: number;

  /** Number of rules that were evaluated */
  rulesEvaluated: number;

  /** Rules that were skipped due to missing required tools */
  rulesSkipped: string[];
}
```

### Task 2: Create Rule Registry Class

**Action:** Implement singleton registry for synthesis rule management
**Files:** src/lib/synthesis/ruleRegistry.ts
**Details:**

```typescript
import type { SynthesisRule, SynthesisContext, SynthesisResult, Insight } from './types';

class SynthesisRuleRegistry {
  private rules = new Map<string, SynthesisRule>();

  /**
   * Register a new synthesis rule
   */
  register(rule: SynthesisRule): void {
    if (this.rules.has(rule.id)) {
      console.warn(`Synthesis rule ${rule.id} already registered, overwriting`);
    }
    this.rules.set(rule.id, rule);
  }

  /**
   * Remove a registered rule
   */
  unregister(id: string): void {
    this.rules.delete(id);
  }

  /**
   * Get a specific rule by ID
   */
  get(id: string): SynthesisRule | undefined {
    return this.rules.get(id);
  }

  /**
   * Get all registered rules
   */
  getAll(): SynthesisRule[] {
    return Array.from(this.rules.values());
  }

  /**
   * Get IDs of all registered rules
   */
  getIds(): string[] {
    return Array.from(this.rules.keys());
  }

  /**
   * Check if a rule is registered
   */
  has(id: string): boolean {
    return this.rules.has(id);
  }

  /**
   * Get count of registered rules
   */
  count(): number {
    return this.rules.size;
  }

  /**
   * Evaluate all registered rules against the provided context
   */
  evaluateAll(context: SynthesisContext): SynthesisResult {
    const allInsights: Insight[] = [];
    const allScores: Record<string, number> = {};
    const rulesSkipped: string[] = [];
    let rulesEvaluated = 0;

    for (const rule of this.rules.values()) {
      // Check if all required tools are present
      const hasRequiredTools = rule.requiredTools.every(
        toolId => context.tools[toolId] !== undefined
      );

      if (!hasRequiredTools) {
        rulesSkipped.push(rule.id);
        continue;
      }

      try {
        // Evaluate the rule
        const insights = rule.evaluate(context);
        allInsights.push(...insights);
        rulesEvaluated++;

        // Calculate scores if the rule provides them
        if (rule.calculateScores) {
          const scores = rule.calculateScores(context);
          Object.assign(allScores, scores);
        }
      } catch (error) {
        console.error(`Synthesis rule ${rule.id} failed:`, error);
        // Continue with other rules even if one fails
      }
    }

    return {
      insights: this.prioritizeInsights(allInsights),
      scores: allScores,
      timestamp: Date.now(),
      rulesEvaluated,
      rulesSkipped
    };
  }

  /**
   * Sort insights by severity and type
   */
  private prioritizeInsights(insights: Insight[]): Insight[] {
    const typeOrder: Record<Insight['type'], number> = {
      gap: 0,
      warning: 1,
      opportunity: 2,
      strength: 3
    };

    return insights.sort((a, b) => {
      // First sort by severity (descending - 5 is most severe)
      if (b.severity !== a.severity) {
        return b.severity - a.severity;
      }
      // Then by type (gaps first, strengths last)
      return typeOrder[a.type] - typeOrder[b.type];
    });
  }

  /**
   * Get rules that can run with currently available tools
   */
  getApplicableRules(availableToolIds: string[]): SynthesisRule[] {
    return this.getAll().filter(rule =>
      rule.requiredTools.every(id => availableToolIds.includes(id))
    );
  }
}

// Singleton instance
export const synthesisRuleRegistry = new SynthesisRuleRegistry();
```

### Task 3: Create Synthesis Index

**Action:** Create barrel export for synthesis module
**Files:** src/lib/synthesis/index.ts
**Details:**

```typescript
// Export registry
export { synthesisRuleRegistry } from './ruleRegistry';

// Export types
export type {
  SynthesisRule,
  SynthesisContext,
  SynthesisResult,
  Insight
} from './types';

// Rules will be imported here as they are created
// Each rule file auto-registers itself when imported
// Example:
// import './rules/executionCapabilityGap';
// import './rules/unmitigatedThreat';
// import './rules/burnoutRisk';
```

### Task 4: Create useSynthesis Hook

**Action:** Create React hook for running synthesis and storing results
**Files:** src/hooks/useSynthesis.ts
**Details:**

```typescript
import { useCallback, useMemo } from 'react';
import { useWorkspaceStore } from '@stores/workspaceStore';
import { synthesisRuleRegistry } from '@lib/synthesis';
import type { SynthesisResult, SynthesisContext } from '@lib/synthesis';

interface UseSynthesisReturn {
  /** Current synthesis results from workspace */
  synthesis: {
    insights: SynthesisResult['insights'];
    scores: Record<string, number>;
  };

  /** Run synthesis with current workspace data */
  runSynthesis: () => SynthesisResult;

  /** Number of registered rules */
  ruleCount: number;

  /** Get insights of a specific type */
  getInsightsByType: (type: 'gap' | 'strength' | 'warning' | 'opportunity') => SynthesisResult['insights'];

  /** Get insights affecting a specific tool */
  getInsightsForTool: (toolId: string) => SynthesisResult['insights'];

  /** Check if synthesis has been run */
  hasRun: boolean;
}

export function useSynthesis(): UseSynthesisReturn {
  const tools = useWorkspaceStore(s => s.tools);
  const meta = useWorkspaceStore(s => s.meta);
  const synthesis = useWorkspaceStore(s => s.synthesis);
  const setSynthesis = useWorkspaceStore(s => s.setSynthesis);

  const runSynthesis = useCallback(() => {
    const context: SynthesisContext = {
      tools,
      meta: {
        companyName: meta.companyName,
        assessmentDate: meta.assessmentDate
      }
    };

    const result = synthesisRuleRegistry.evaluateAll(context);

    // Save to workspace store
    setSynthesis({
      insights: result.insights,
      scores: result.scores
    });

    return result;
  }, [tools, meta, setSynthesis]);

  const getInsightsByType = useCallback(
    (type: 'gap' | 'strength' | 'warning' | 'opportunity') => {
      return synthesis.insights.filter(insight => insight.type === type);
    },
    [synthesis.insights]
  );

  const getInsightsForTool = useCallback(
    (toolId: string) => {
      return synthesis.insights.filter(insight =>
        insight.affectedTools.includes(toolId)
      );
    },
    [synthesis.insights]
  );

  const hasRun = useMemo(
    () => synthesis.insights.length > 0 || Object.keys(synthesis.scores).length > 0,
    [synthesis]
  );

  return {
    synthesis,
    runSynthesis,
    ruleCount: synthesisRuleRegistry.count(),
    getInsightsByType,
    getInsightsForTool,
    hasRun
  };
}
```

### Task 5: Create Example Rule Template

**Action:** Create a documented example rule showing the pattern
**Files:** src/lib/synthesis/rules/_template.ts
**Details:**

```typescript
/**
 * TEMPLATE: Copy this file to create a new synthesis rule
 *
 * Naming convention: {code}-{descriptive-name}.ts
 * Example: E1-execution-capability-gap.ts
 */

import type { SynthesisRule, SynthesisContext, Insight } from '../types';
import { synthesisRuleRegistry } from '../ruleRegistry';

/**
 * Rule: [Name]
 * Code: [E1-E11]
 *
 * Description: [What this rule detects]
 *
 * Triggers when:
 * - [Condition 1]
 * - [Condition 2]
 *
 * Required tools:
 * - [tool-id-1] - [what data is used]
 * - [tool-id-2] - [what data is used]
 */
const exampleRule: SynthesisRule = {
  id: 'EXAMPLE-rule-name',
  name: 'Example Rule Name',
  description: 'Detects [specific condition] across [relevant tools]',
  requiredTools: ['tool-id-1', 'tool-id-2'],

  evaluate: (context: SynthesisContext): Insight[] => {
    const tool1Data = context.tools['tool-id-1'] as any;
    const tool2Data = context.tools['tool-id-2'] as any;

    const insights: Insight[] = [];

    // TODO: Implement rule logic
    // Example:
    // const metricValue = tool1Data?.someMetric || 0;
    // const threshold = 6;
    //
    // if (metricValue < threshold) {
    //   insights.push({
    //     id: `EXAMPLE-${Date.now()}`,
    //     ruleId: 'EXAMPLE-rule-name',
    //     type: 'gap',
    //     severity: 4,
    //     title: 'Gap Detected',
    //     description: `Metric value (${metricValue}) is below threshold (${threshold}).`,
    //     recommendation: 'Take action X to improve metric.',
    //     affectedTools: ['tool-id-1', 'tool-id-2'],
    //     data: { metricValue, threshold }
    //   });
    // }

    return insights;
  },

  // Optional: Calculate scores for synthesis dashboard
  calculateScores: (context: SynthesisContext) => {
    // const tool1Data = context.tools['tool-id-1'] as any;
    // return {
    //   exampleScore: tool1Data?.someMetric || 0
    // };
    return {};
  }
};

// Auto-register when this module is imported
synthesisRuleRegistry.register(exampleRule);

export default exampleRule;
```

### Task 6: Update Types Index

**Action:** Add synthesis types to central types export
**Files:** src/types/index.ts
**Details:**

```typescript
export * from './tool';
export * from './workspace';

// Re-export synthesis types for convenience
export type {
  SynthesisRule,
  SynthesisContext,
  SynthesisResult,
  Insight
} from '@lib/synthesis/types';
```

## Verification

- [ ] `synthesisRuleRegistry.register(rule)` adds rule to registry
- [ ] `synthesisRuleRegistry.get('rule-id')` retrieves registered rule
- [ ] `synthesisRuleRegistry.getAll()` returns all registered rules
- [ ] `synthesisRuleRegistry.evaluateAll(context)` runs all applicable rules
- [ ] Rules with missing required tools are skipped (not error)
- [ ] Failed rules don't crash the entire synthesis run
- [ ] Insights are sorted by severity (5 first) then type (gaps first)
- [ ] `useSynthesis().runSynthesis()` executes synthesis and saves to store
- [ ] `useSynthesis().getInsightsByType('gap')` filters correctly
- [ ] `useSynthesis().getInsightsForTool('tool-id')` filters correctly
- [ ] Template rule file serves as documentation for adding new rules
- [ ] TypeScript provides full type safety for rule definitions

## Must-Haves

- Synthesis rule registry for adding new rules without modifying engine core (ARC-05)
- Rules are self-registering modules
- Context provides access to all tool data
- Insights are prioritized by severity
- Rules gracefully handle missing data
- Clear documentation/template for adding new rules
